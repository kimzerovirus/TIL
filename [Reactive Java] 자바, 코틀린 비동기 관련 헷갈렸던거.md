**context** : 우리말로 문맥, 맥락이라는 단어이지만 프로그래밍 세계에서는 어떠한 상황에서 그 상황을 처리하기 위해 필요한 정보를 의미한다.



코루틴은 비선점형 멀티태스킹이다.

아직 자바에서 Future는 선점형으로만 되는듯



> **선점형 멀티태스킹 (시분할 멀티태스킹)
> **선점 = 특정 작업에서 CPU를 사용할 차례를 주기 전, 한 작업에 할당할 시간을 결정하는 작업
> 선점을 위한 일반적인 기준은 작업의 경과 시간이므로 이를 시간 공유 / 시간 분할이라고 한다.

여기에서 선점의 주체는 프로세스가 아닌 운영체제 라는 사실을 잊지말자.

> **비선점형 멀티캐스킹**
> OS가 CPU 관리에 대해서 점유하지 않고 응용 프로그램이 모든 작업을 끝내서 CPU 사용이 더이상 불필요한 경우, 이를 반환하여 필요한 프로세스가 이를 가져갈 수 있게 하는 방식

여기에선 운영체제의 개입 없이 프로세스 간 작업에 따라 자원을 반환하고 이를 가져가서 사용하게 된다. = 컨텍스트 스위칭 비용이 없다.

스레드는 일반적으로 **선점형으로 멀티 태스킹**이 된다. 경량 스레드라고 불리는 코루틴은 **협력적(co)으로 멀티 태스킹**이 이루어진다.

따라서 코루틴은 실행 중인 프로세스에서 다른 프로세스로 Context Switching을 하지 않고 프로세스가 주기적으로 혹은 유휴상태이거나 논리적으로 차단 될 때 자발적으로 자원에 대한 제어를 양보하는 것이다.

논리적으로 중단-재개를 반복한다.

> **그래서 코루틴은 동시성을 제공하지만 병렬성을 제공하진 않는다.**
>
> 즉, 실제로 여러 작업이 동시에 실행되는 방식이 아닌 동시에 실행되는 것처럼 보이는 것이다.

코루틴은 실제로 스레드가 아니다.
스레드를 사용하지만 특정 스레드에 바인딩 되어 동작하지도 않는다.

그렇다면 왜 경량 스레드라고 불리는걸까?

코루틴은 스레드에 비해 실시간 Context 사용이 가능하다.
코루틴 간 전환시에 시스템 호출/ 차단 호출이 불필요하며 동기화 기본 요소(뮤텍스, 세마포어 등) 가 불필요하다.

이러한 장점이 코루틴이 경량화된 스레드라고 불리는 이유 같다.

그러한 경량 스레드인 코루틴은 특정 중단 지점(suspend points)을 갖는다.

특정 중단 지점을 통해 스레드 내에서 코루틴을 중지하고 재개할 수 있다.
(이러한 마법이 어떻게 이루어질까)

더 정확히는 하나의 코루틴은 하나의 작업이 아닌 특정 순서의 보장으로 생각이 된다. **특정 순서가 보장된 하위 작업의 시퀀스 이다.**
코드가 하나의 순차적 블럭안에 있는 것처럼 보여도 일시중단 함수에 대한 각 호출은 코루틴 안에서 새로운 ‘하위 작업’으로 구분한다.

## suspend function

여러 하위 작업으로 구분되어 있으며 이를 협력적으로 수행하여 비동기적인 코드에 가까워질 수 있는 데에는 suspend keyword를 빼놓을 수 없다.

어떻게 보면 코루틴의 가장 마법과 같은 키워드라고 생각한다.

근데 이러한 키워드가 실제 컴파일 시점에는 CPS 형식으로 변환되어 실행된다는 것이다. (이게 마법의 핵심일 것이다.)

그럼 suspend function의 내부 동작 방식을 알기 이전에 CPS에 대해 먼저 살펴보자.



---



콜백 형식이 아닌 await이 가능한 이유가 요거인듯?

OS가 CPU 상태에 따라 쓰레드 작업을 스케줄링 하지 않고 개발자가 직접 작업을 스케줄링 하기에 비동기 코드 작성이 간단합니다.



---



기존 Java의 스레드 모델은 Native Thread로, Java의 유저 스레드를 만들면 Java Native Interface(JNI)를 통해 커널 영역을 호출하여 OS가 커널 스레드를 생성하고 매핑하여 작업을 수행하는 형태였습니다.

Java의 스레드는 I/O, interrupt, sleep과 같은 상황에 block/waiting 상태가 되는데, 이때 **다른 스레드가 커널 스레드를 점유하여 작업을 수행하는 것을 ‘컨텍스트 스위치’**라고 합니다.

이러한 스레드 모델은 **기존 프로세스 모델을 잘게 쪼개** 프로세스 내의 공통된 부분은 공유하면서, 작은 여러 실행단위를 번갈아 가면서 수행할 수 있도록 만들었습니다. 스레드는 프로세스의 공통영역을 제외하고 만들어지기 때문에, 프로세스에 비해 크기가 작아서 생성 비용이 적고, 컨텍스트 스위칭 비용이 저렴했기 때문에 주목받아 왔습니다.

그러나, 요청량이 급격하게 증가하는 서버 환경에서는 갈수록 더 많은 스레드 수를 요구하게 되었습니다. 스레드의 사이즈가 프로세스에 비해 작다고 해도, 스레드 1개당 1MB 사이즈라고 가정하면, 4GB 메모리 환경에서도 많아야 4,000개의 스레드를 가질 수 있습니다. 이처럼 메모리가 제한된 환경에서는 생성할 수 있는 스레드 수에 한계가 있었고, 스레드가 많아지면서 컨텍스트 스위칭 비용도 기하급수적으로 늘어나게 되었습니다.

이런 한계를 겪던 서버는 더 많은 요청 처리량과 컨텍스트 스위칭 비용을 줄여야 했는데, 이를 위해 나타난 스레드 모델이 경량 스레드 모델인 Virtual Thread입니다.

![img](https://techblog.woowahan.com/wp-content/uploads/2023/12/5.png)

Virtual Thread는 기존 Java의 스레드 모델과 달리, 플랫폼 스레드와 가상 스레드로 나뉩니다. 플랫폼 스레드 위에서 여러 Virtual Thread가 번갈아 가며 실행되는 형태로 동작합니다. 마치 커널 스레드와 유저 스레드가 매핑되는 형태랑 비슷합니다.

여기서 가장 큰 특징은 **Virtual Thread는 컨텍스트 스위칭 비용이 저렴**하다는 것입니다.

|                 | Thread | Virtual Thread |
| --------------- | ------ | -------------- |
| Stack 사이즈    | ~2MB   | ~10KB          |
| 생성시간        | ~1ms   | ~1µs           |
| 컨텍스트 스위칭 | ~100µs | ~10µs          |



###### 참고 자료

- https://medium.com/@wodbs135/coroutine-suspend-function-2c11a8f700d5
- https://techblog.woowahan.com/15398/
- https://dev.gmarket.com/82


docker mysql

```sql
docker run \
  --name mysql_practice \
  -e MYSQL_ROOT_PASSWORD=1234 \
  -e MYSQL_DATABASE=practice \
  -v mysql_db:/var/lib/mysql \
  -p 3306:3306 \
  -d \
  mysql:8.0

# root
```

docker postgresql

```sql
docker run \
  --name postgre_practice \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=1234 \
  -e POSTGRES_DB=practice \
  -v pg_data:/var/lib/postgresql/data \
  -p 5432:5432 \
  -d \
  postgres:15
```

##### PK 뭘로 만들까

- uuidv4 : 랜덤하게 생성해주지만 인덱스 파편화로 인한 성능 저하 문제가 있음
- uuidv7 : 타임스탬프 기반으로 앞자리를 결정하므로 인덱스 파편화 문제는 없음
- snowflake ID

|             | auto increment id | uuid v4                                  | uuid v7 / snowflake |
| ----------- | ----------------- | ---------------------------------------- | ------------------- |
| 인덱스 효율 | 높음              | 낮음 (랜덤)                              | 높음                |
| 저장 크기   | 작음              | 큼 (인덱스 등의 문제로 v7보다 더 필요함) | 중간                |

## DB 설계시 원칙

> 처음 설계시에는 중복을 없이 설계한다. (정규화) 이후 성능 또는 개발 편의등을 위한 트레이드 오프(역정규화)

##### 연관관계

1:N, N:M 1:1 연관관계 설정이 헷갈릴 때는 엑셀과 같은 표에 컬럼을 나열해보고 직접 데이터를 임시로 넣어보며 설정해보면 바로 알 수 있음. 한 칸에 여러개의 요소를 넣어야 한다면 1:N 관계가 성리합는것 > 다른 테이블로 분리 > 여기서도 여러개로 표현된다면 N:M 관계

학생
| id   | 이름   | 수강 과목  |
| ---- | ------ | ---------- |
| 1    | 김대박 | 수학, 영어 |
| 2    | 홍길동 | 수학       |

과목
| id   | 과목명 |수강중인 학생|
| ---- | ------ | ---------- |
| 1    | 수학   |김대박, 홍길동|
| 2    | 영어   |김대박|

학생-과목
| id   | 학생 id (PK) | 과목 id (PK) |
| ---- | ------------ | ------------ |
| 1    | 1            | 1            |
| 2    | 1            | 2            |
| 3    | 2            | 1            |

##### 자기참조 관계

한 엔티티가 자기 자신과 관계를 맺는 구조로 self join해야함

- 자기 자신에 대한 외래키 참조를 통해 구현
- depth컬럼을 통해 순환 참조 및 무한 루프 방지

### 정규화 & 역정규화

정규화는 데이터 중복과 이상현상을 줄이고 무결성을 유지하기 위해 테이블 구조를 분해하는 과정, 하지만 과도한 분해는 수 많은 조인으로 이어져 읽기 성능 저하가 올 수도 있음, 이럴 경우 역정규화 (쿼리 성능 최적화나 편의를 위해 반대로 분해한것을 다시 합치는 작업)를 한다.

##### 정규형

- **1NF (제1 정규형)**

  - 하나의 셀에는 하나의 값만 존재해야 함.
  - `,`와 같은 구분자로 리스트를 집어 넣지 말라는 것

- **2NF (제2 정규형)**
  - 부분 함수 종속을 제거해야 함 (모든 데이터가 기본 키 전체에 종속).
  - 게시글 테이블에 작성자 이름과 같은 데이터는 사용자 테이블로 별도 분리
  
- **3NF (제3 정규형)**
  - 이행적 함수 종속을 제거해야 함 (기본 키가 아닌 속성끼리 종속되는 것 제거).
  - **사원 테이블**에 **부서 이름**을 넣지 말고, **부서 ID**로만 참조하게 한 후 **부서 테이블**로 분리
  
- **BCNF (보이스-코드 정규형)**
  - 모든 결정자는 후보 키여야 함.
  - 3NF보다 엄격한 버전! 테이블에 **겹치는 여러 개의 후보 키**가 있을 때 발생할 수 있는 데이터 중복을 완전히 제거.
  
- **4NF (제4 정규형)**

  - 다중 값 종속(MVD)을 제거해야 함.
  - 한 사람의 **기술 리스트**와 **취미 리스트**가 **독립적**이라면, 이 둘을 한 테이블에 같이 넣어 불필요하게 모든 조합을 반복하는 중복을 막을것

- **5NF (제5 정규형)**

  - 결합 종속을 제거해야 함 (손실 없는 조인 분해).
  - 테이블을 더 이상 손실 없이 분해할 수 없을 때까지 분해해야 함. 쪼갰다가 다시 합쳐도 원래 정보와 동일하게 복원될 수 있도록 중복을 최종적으로 제거

##### 역정규화가 효과적인 경우

- 다수의 JOIN이 필요한 경우
- 계산된 값을 미리 저장 해야 할 때 (조회수, 좋아요, 총 판매액 등)

##### 역정규화의 단점

역정규화는 성능 개선의 이점을 얻을 수도 있지만 데이터 무결성을 해친다는 트레이드 오프가 있음

- 데이터 중복 문제 및 저장공간 증가
- 데이터 불일치 위험
- 쓰기 성능 저하

관계형 DB의 장점인 연관관계를 포기해야 하는 경우가 만다면, 굳이 RDB를 사용해야 할까라는 근본적인 의문이 있음. NoSQL을 적절히 사용할 수 있는 상황일 수도 있음

약간의 데이터 정합성이 깨져도 상관없거나 준 실시간 동기화 되어도 상관없는 케이스 >>> 주기적 정합성 체크 및 동기화는 필요할지도 (찜이 일 일정 개수를 넘었을 때 10K와 같이 표현할 때 꼭 눌렀을 때 즉시 증가 되어야 할까, 그냥 내 찜 목록에 들어가는게 중요하지 개수는 준실시간으로 동작해도 서비스 영향이 크지 않음)

product에 count를 두지않고 like 테이블과 별도로 product_meta테이블을 만들어 여기에서 count와 같은 데이터를 관리할 수도 있음 이렇게 분리하면 좋아요를 누르는 트래픽이 많다면 product_meta 안에서만 경합이 일어나서 product에 영향을 주지 않음. 즉 event로 완전히 격리하여 async하게 돌릴 수 있다

## 인덱스

##### B+트리 (balanced)

> 개선된 균형 잡히 트리 구조, 데이터의 검색/삽입/삭제 성능이 향상되었다.

인덱스 사용 패턴

일반적으로 데이터베이스는 인덱스를 한 번만 탄다 따라서 여러 컬럼이 조건이면 복합 인덱스(Multi-Column Index)를 걸어야 한다.

- 선두 컬럼부터 순서대로 활용 가능 A, B, C로 구성된 다중 컬럼 인덱스이면 (A), (A, B), (A, C), (A, B, C) 의 케이스에서만 효율적 >> where, group by, order by 등 컬럼 순서를 인덱스와 일치해야함

유니크 제약

- 제약 조건에 맞춰 인덱스도 자동 생성됨, 존재여부를 가장 빠르게 판단할 방법이니깐



##### 커버링 인덱스

- 장점: 특정 쿼리가 필요로 하는 모든 데이터를 인덱스 내에 포함하여 테이블 데이터에 접근하지 않고 빠르게 처리
- 단점: 쿼리에 필요한 모든 컬럼을 인덱스로 저장하므로 저장 공간이 증가하고 쓰기 성능이 저하된다.

extra 항목에 using index


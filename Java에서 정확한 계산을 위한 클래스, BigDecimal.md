# Java에서 정확한 계산을 위한 클래스, BicDecimal

## 자바 원시타입 float, double 계산의 문제점

자바에서 소수(decimal) 연산을 할 때, 기대와 다른 엉뚱한 값이 나오는 걸 볼 수 있다.

```java
double a = 0.1;
double b = 0.2;

System.out.print(a + b ); // 0.30000000000000004
```

다음과 같이 똑같은 값을 더하고 빼도 엉뚱한 값이 나오는것을 확인할 수 있다.

```java
System.out.println ( .1f + .1f + .1f - .1f - .1f - .1f ); // 1.4901161E-8
System.out.println ( .1d + .1d + .1d - .1d - .1d - .1d ); // 2.7755575615628914E-17
```

오차가 발생하는 이유는 float과 double은 정확한 값이 아닌 근삿값을 담고 있어서 발생하는 *부동소수점 타입* 의 대표적인 문제점이다.

## 고정소수점과 부동소수점

컴퓨터에서 실수를 표현하는 방식에는 크게 두가지가 있음.

##### 고정 소수점

>  실수를 부호 비트(signed bit), 정수부와 소수부로 나누고 자릿수를 고정하여 실수를 표현하는 방식

| 부호  | 정수부 | 소수부 |
| ----- | ------ | ------ |
| 1비트 | 15비트 | 16비트 |

고정소수점은 각 부분을 자릿수를 고정으로 나누어 저장하므로 간단하게 구현 가능하지만, 자릿수가 제한되어 있다는 치명적인 단점이 있음 따라서 표현할 수 있는 수의 범위가 한점적이므로 더 넓은 범위의 실수를 표현하기 위해 부동소수점이라는 개념이 등장함

##### 부동소수점 

> 실수를 부호부(sign), 가수부(mantissa), 지수부(exponent)로 나구고, 정규화된(normalized) 값을 각 비트에 나눠 담아 실수를 표현하는 방식

| 부호  | 가수부 | 지수부 |
| ----- | ------ | ------ |
| 1비트 | 8비트  | 23비트 |

예를 들면 12.3456을 저장할 경우, 표현식을 0.123456 * 10^2로 변경한 다음, 가수부에는 0.123456을 저장하고 지수부에는 2를 저장하는 방식이다. 실제로는 [IEEE 754 표준](https://en.wikipedia.org/wiki/IEEE_754)에 따라서 지수부에 bias라는 값을 더해주는 과정을 거치게 된다. <br/>

하지만 부동소수점은 고정소수점 표현방식에 비해 더 넓은 실수 범위를 표현할 수 있지만, 위에서 말했듯이 근본적으로 2진수를 사용하므로 소수를 표현할 때 오차가 발생하게 된다. 0.3과 같은 수를 2진수로 변환하면 0.0100110011..로 특정수가 무한 반복되게 된다.

###### 정규화

여기서 말하는 정규화는 소수점을 이동시키는것을 말한다. 쉽게 말해, 2진수를 1.xxx⋯*2𝑛 형태로 나타내는 것, 10진수 7.625을 정규화 한다면 먼저 이를 2진수로 변환하면 111.101(2)이고, 이를 다시 정규화하면 1.11101(2) * 2^2



### 원시타입 자료형의 크기와 표현 가능 범위

| Primitive type | 메모리 크기                                                  | 값 범위                                    |
| -------------- | ------------------------------------------------------------ | ------------------------------------------ |
| byte           | 8 비트                                                       | -128 ~ 127                                 |
| short          | 16 비트                                                      | -32768 ~ 32767                             |
| char           | 16 비트                                                      | 0 ~ 65536                                  |
| int            | 32 비트                                                      | -2147483648 ~ 2147483647                   |
| long           | 64 비트                                                      | -9223372036854775808 ~ 9223372036854775807 |
| float          | 32 비트                                                      | (2의 -149승) ~ ((2의 -23승) * 2의 127승)   |
| double         | 64 비트                                                      | (-2의 63승) ~ ((2의 63승) - 1)             |
| boolean        | 8비트(배열로 사용하는 경우), <br/>32비트(배열로 사용하지 않는 경우) | true 또는 false                            |



## BigDecimal

> 불변의 성질을 가지며, 임의 정밀도(*arbitrary-precision, 무한대에 가까운 자릿수를 표현할 수 있는 것을 의미*)와 부호를 지니는 10진수

BigDecimal은 내부적으로 임의 정밀도 연산을 이용하며, 동시에 불변이므로 BigDecimal 객체 간의 연산마다 새로운 객체를 생성한다. 따라서 float이나 double과 기본 타입 자료형들에 비해 연산 속도가 훨씬 느리다. 그러므로 돈과 같이 정확한 계산이 필요한 경우가 아니면 자주 사용되지 않음



double과 float은 `new BigDecimal(num)` 생성자를 통해 생성해야됨, 생성자를 통해 생성하면 문자열로 감싸서 적용되므로 더 정확함?



0 과 10은 `BigDecimal.ZERO`, `BigDecimal.TEN` 으로 제공됨



## BigDecimal의 사칙연산

##### Add 덧셈

##### Subtract 뺄셈

##### Multiply 곱셈

##### Divide 나눗셈



**출처 및 참고**

- https://dev.gmarket.com/75

- https://docs.oracle.com/javase/8/docs/api/
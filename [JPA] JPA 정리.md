# JPA

> Java Persistence API는 자바 ORM 기술의 표준이다. 애플리케이션과 JDBC 사이에서 동작한다. 따라서 JDBC의 한계인 Non-blocking환경에서는 적합하지 않다. (JDBC는 블로킹 기반으로 설계되어 있다.)

- 속성

  - jpa 표준 속성 : jakarta.persistence 이하 속성 값 (특정 구현체에 종속되지 않는다)

  - 하이버네이트 속성: hibernate.dialect (jpa 구현체 중 하나인 하이버네이트의 설정)

- 데이터베이스 방언

  - MySQL은 VARCHAR, 오라클은 VARCHAR2
  - 문자열을 자르는 함수 ANSI표준은 `SUBSTRING` 이지만 오라클의 경우 `SUBSTR` 이다.
  - 페이징 처리의 경우 MySQL, Postgres 등은  `LIMIT` 을 쓰지만  오라클 계열은 `ROWNUM` 을 사용한다.
    - 특정 데이터베이스 방언이므로 JPQL에서도  `LIMIT` 쿼리 지원하지 않음!!! native query 작성 또는 querydsl에서는 limit메서드 사용

## 영속성

### 엔티티 매니저 팩토리

앤티티 매니저 팩토리는 앤티티 매니저를 만든다. 다만 만드는 비용이 크므로(JPA를 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서는 데이터베이스와 연결하는 커넥션 풀도 생성한다.) 애플리케이션 전체에서 하나만 만들어 공유하도록 설계 되어 있음.

### 엔티티 메니저

JPA의 대부분의 기능은 엔티티 메니저가 제공한다. 대표적으로 CRUD작업 등을 할 수 있다. 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유할 수 있지만, 엔티티 매니저는 데이터 베이스 커넥션과 밀접한 관계가 있으므로, 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 공유하면 안됨!<br/>

엔티티 메니저는 데이터베이스 연결이 꼭 필요한 시점까지 DB커넥션을 얻지 않음

### 트랜잭션 관리

JPA는 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 데이터를 변경한다면 예외가 발생한다.

- **Dirty Checking (변경 감지)** : save를 별도로 하지 않아도 상태의 변화를 체크하여 update해준다. JPA에서는 트랜잭션이 끝나는 시점에 변화가 있는 모든 엔티티 객체를 데이터베이스에 자동으로 반영한다. 변화의 기준은 최초 조회 상태이다.
  - JPA는 엔티티를 조회하면 최초 상태를 그대로 스냅샷을 만든다.
  - 트랜잭션이 끝나는 시점에 이 스냅샷과 현재 엔티티 객체와 비교하여 Update Query를 실행한다.
  - 이러한 상태 변화 검사 대상은 영속성 컨텍스트가 관리하는 엔티티에만 적용된다.
    - 영속 상태가 아닌 detach된 엔티티 (준영속) 또는 DB에 반영되기 전, 처음으로 생성된 엔티티 (비영속) 들은 Dirty Checking 대상에 포함되지 않는다.
  - 전체 필드를 업데이트하는 방식이 기본값이다.
    - 변경 필드만 반영하고 싶다면 `@DynamicUpdate` 를 엔티티 최상단에 선언해주면 된다. (일반적으로 필드가 30개가 넘어간다면, 동적 SQL을 적용하는게 빠르다고 한다.)
    - 모든 필드를 업데이트하면 데이터 전송량이 크지만 여러 이점이 있다.
      - 업데이트 SQL이 항상 같으므로 SQL 재사용성이 증가한다. 따라서 애플리케이션 로딩 시점에 SQL을 미리 만들어 두고 재사용 할 수 있다.
  - 동작 순서
    1. 애플리케이션에서 트랜잭션 커밋 시도시 엔티티 메니저 내부에서 `flush()` 호출
    2. 엔티티와 스냅샷 비교하여 변경이 있는 엔티티를 찾는다.
    3. 변경된 엔티티에 대한 업데이트 SQL을 쓰기 지연 SQL 저장소에 추가한다.
    4. 쓰기 지연 저장소의 SQL을 실제 데이터베이스에 실행한다.
    5. 데이터베이스의 트랜잭션을 커밋한다.

### 영속성 컨텍스트의 특징

> 엔티티를 관리하는 저장소로 엔티티 메니저에서 엔티티를 조회하거나 저장하면 영속성 컨텍스트에서 보관하고 관리한다.

- 영속성 컨텍스트는 엔티티의 식별자 값으로 구분하므로 반드시 식별자(id)가 있어야함

- 영속성 컨텍스트에 엔티티를 저장한 후 flush 해야 데이터베이스에 실제로 저장됨

- 영속성 컨텍스트가 엔티티를 관리하는 이점

  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
    - 엔티티 메니저는 트랜잭션을 커밋하기 직전까지 엔티티를 실제 데이터베이스에 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둔다. 그리고 트랜잭션을 커밋할 때 한번에 SQL을 실행한다.
    - 트랜잭션을 커밋하지 않는 이상 실제 데이터베이스에 반영되지 않는다. 그러므로 커밋 직전에만 데이터베이스에 SQL에 전달 할 수 있다면 트랜잭션을 지원하는 쓰기 지연이 가능하게 된다.
  - Dirty Checking
  - 지연 로딩

- 영속 엔티티의 동일성 보장
  - `EntityManager.find()` 메서드로 엔티티를 찾으면 수십번을 반복해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다.


### 엔티티의 생명주기

- **비영속 (new/transient)** : 영속성 컨텍스트와 전혀 관계가 없는 상태
- **영속 (managed)** : 영속성 컨텍스트에 저장된 상태
- **준영속 (detached)** : 영속성 컨텍스트에 저장되었다가 분리된 상태

  - `EntityManager.detach(T entity)` : 특정 엔티티만 준영속 상태로 전환한다.
  - `EntityManager.clear()` : 영속성 컨텍스트(1차 캐시)를 초기화한다. EntityManager는 살아 있지만, 관리하던 엔티티들은 모두 준영속 상태가 된다. (캐시 청소?)
  - `EntityManager.close()` : 영속성 컨텍스트를 종료한다. 이후부터는 EntityManager로 persist, find, clear 등이 불가능하며, 새로운 EntityManager를 만들어야 한다. (완전히 종료)
  - 준영속 상태의 특징
    - 거의 비영속 상태에 가깝다. 1차 캐시, 쓰기 지연 등 모든 기능이 작동하지 않음
    - 식별자 값을 가지고 있다.
    - 지연 로딩을 할 수 없다. 지연 로딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방식이다.
    - 준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 `merge(T entity)` (병합) 하면 된다.

- **삭제 (removed)** : 삭제된 상태

#### 비영속 상태와 준영속 상태의 차이점

비영속 상태는 영속성 컨텍스트가 한번도 관리를 한적이 없는 상태이므로 식별자를 가지고 있지 않다. 하지만 준영속 상태는 영속성 컨텍스트가 관리를 하다가 더이상 관리를 하지 않는 상태가 된것이므로 식별자 값이 존재한다.

### 엔티티 조회

영속성 컨텍스트 내부에는 캐시가 있다. 이 캐시는 Map으로 이루어져 있기 때문에 엔티티는 고유의 id가 반드시 필요하다. 즉, 1차 캐시의 키는 식별자 값이다. `EntityManager.find()` 메서드를 실행하면 데이터베이스 찾는게 아니라 우선 메모리에 있는 1차 캐시에서 조회 후 없으면 데이터베이스에서 조회한다. 따라서 찾는 값이 1차 캐시에 없다면 데이터베이스에서 찾은 후 1차 캐시에 저장하여 엔티티를 영속 상태로 만들고 엔티티를 반환한다.

### flush

jpa에서 제공하는 `flush()` 메서드는 영속성 컨텍스트의 변경 내용을 실제 데이터베이스에 반영하는 기능을 제공한다. 다음과 같은 작업을 수행한다.

- 변경 감지 작업 수행
- 쓰기 지연 SQL 저장소의 SQL을 실제 데이터베이스에 전송 (CREATE, UPDATE, DELETE)

영속성 컨텍스트에 flush하는 방법은 3가지가 있다.

- `flush()` 메서드 직접 호출
- 트랜잭션 커밋 시 자동 호출
- JPQL 쿼리 실행시 자동 호출



###### 참고

- [JPA ORM 표준 프로그래밍](https://www.yes24.com/product/goods/19040233)
- [더티 체킹](https://jojoldu.tistory.com/415)

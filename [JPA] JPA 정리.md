# JPA

> Java Persistence API는 자바 ORM 기술의 표준이다. 애플리케이션과 JDBC 사이에서 동작한다. 따라서 JDBC의 한계인 Non-blocking환경에서는 적합하지 않다. (JDBC는 블로킹 기반으로 설계되어 있다.)

**속성 값**

- jpa 표준 속성 : jakarta.persistence 이하 속성 값 (특정 구현체에 종속되지 않는다)

- 하이버네이트 속성: hibernate.dialect (jpa 구현체 중 하나인 하이버네이트의 설정)

**dialect 데이터베이스 방언**

- MySQL은 VARCHAR, 오라클은 VARCHAR2
- 문자열을 자르는 함수 ANSI표준은 `SUBSTRING` 이지만 오라클의 경우 `SUBSTR` 이다.
- 페이징 처리의 경우 MySQL, Postgres 등은  `LIMIT` 을 쓰지만  오라클 계열은 `ROWNUM` 을 사용한다.
  - 특정 데이터베이스 방언이므로 JPQL에서도  `LIMIT` 쿼리 지원하지 않음!!! native query 작성, `top1`사용 또는 querydsl에서는 `limit()` 사용

## 영속성

### 엔티티 매니저 팩토리

앤티티 매니저 팩토리는 앤티티 매니저를 만든다. 다만 만드는 비용이 크므로(JPA를 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서는 데이터베이스와 연결하는 커넥션 풀도 생성한다.) 애플리케이션 전체에서 하나만 만들어 공유하도록 설계 되어 있음.

### 엔티티 메니저

JPA의 대부분의 기능은 엔티티 메니저가 제공한다. 대표적으로 CRUD작업 등을 할 수 있다. 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유할 수 있지만, 엔티티 매니저는 데이터 베이스 커넥션과 밀접한 관계가 있으므로, 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 공유하면 안됨!<br/>

엔티티 메니저는 데이터베이스 연결이 꼭 필요한 시점까지 DB커넥션을 얻지 않음

### 트랜잭션 관리

JPA는 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 데이터를 변경한다면 예외가 발생한다.

- **Dirty Checking (변경 감지)** : save를 별도로 하지 않아도 상태의 변화를 체크하여 update해준다. JPA에서는 트랜잭션이 끝나는 시점에 변화가 있는 모든 엔티티 객체를 데이터베이스에 자동으로 반영한다. 변화의 기준은 최초 조회 상태이다.
  - JPA는 엔티티를 조회하면 최초 상태를 그대로 스냅샷을 만든다.
  - 트랜잭션이 끝나는 시점에 이 스냅샷과 현재 엔티티 객체와 비교하여 Update Query를 실행한다.
  - 이러한 상태 변화 검사 대상은 영속성 컨텍스트가 관리하는 엔티티에만 적용된다.
    - 영속 상태가 아닌 detach된 엔티티 (준영속) 또는 DB에 반영되기 전, 처음으로 생성된 엔티티 (비영속) 들은 Dirty Checking 대상에 포함되지 않는다.
  - 전체 필드를 업데이트하는 방식이 기본값이다.
    - 변경 필드만 반영하고 싶다면 `@DynamicUpdate` 를 엔티티 최상단에 선언해주면 된다. (일반적으로 필드가 30개가 넘어간다면, 동적 SQL을 적용하는게 빠르다고 한다.)
    - 모든 필드를 업데이트하면 데이터 전송량이 크지만 여러 이점이 있다.
      - 업데이트 SQL이 항상 같으므로 SQL 재사용성이 증가한다. 따라서 애플리케이션 로딩 시점에 SQL을 미리 만들어 두고 재사용 할 수 있다.
  - 동작 순서
    1. 애플리케이션에서 트랜잭션 커밋 시도시 엔티티 메니저 내부에서 `flush()` 호출
    2. 엔티티와 스냅샷 비교하여 변경이 있는 엔티티를 찾는다.
    3. 변경된 엔티티에 대한 업데이트 SQL을 쓰기 지연 SQL 저장소에 추가한다.
    4. 쓰기 지연 저장소의 SQL을 실제 데이터베이스에 실행한다.
    5. 데이터베이스의 트랜잭션을 커밋한다.

### 영속성 컨텍스트의 특징

> 엔티티를 관리하는 저장소로 엔티티 메니저에서 엔티티를 조회하거나 저장하면 영속성 컨텍스트에서 보관하고 관리한다.

- 영속성 컨텍스트는 엔티티의 식별자 값으로 구분하므로 반드시 식별자(id)가 있어야함

- 영속성 컨텍스트에 엔티티를 저장한 후 flush 해야 데이터베이스에 실제로 저장됨

- 영속성 컨텍스트가 엔티티를 관리하는 이점

  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
    - 엔티티 메니저는 트랜잭션을 커밋하기 직전까지 엔티티를 실제 데이터베이스에 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둔다. 그리고 트랜잭션을 커밋할 때 한번에 SQL을 실행한다.
    - 트랜잭션을 커밋하지 않는 이상 실제 데이터베이스에 반영되지 않는다. 그러므로 커밋 직전에만 데이터베이스에 SQL에 전달 할 수 있다면 트랜잭션을 지원하는 쓰기 지연이 가능하게 된다.
  - Dirty Checking
  - 지연 로딩

- 영속 엔티티의 동일성 보장
  - `EntityManager.find()` 메서드로 엔티티를 찾으면 수십번을 반복해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다.


### 엔티티의 생명주기

- **비영속 (new/transient)** : 영속성 컨텍스트와 전혀 관계가 없는 상태
- **영속 (managed)** : 영속성 컨텍스트에 저장된 상태
- **준영속 (detached)** : 영속성 컨텍스트에 저장되었다가 분리된 상태

  - `EntityManager.detach(T entity)` : 특정 엔티티만 준영속 상태로 전환한다.
  - `EntityManager.clear()` : 영속성 컨텍스트(1차 캐시)를 초기화한다. EntityManager는 살아 있지만, 관리하던 엔티티들은 모두 준영속 상태가 된다. (캐시 청소?)
  - `EntityManager.close()` : 영속성 컨텍스트를 종료한다. 이후부터는 EntityManager로 persist, find, clear 등이 불가능하며, 새로운 EntityManager를 만들어야 한다. (완전히 종료)
  - 준영속 상태의 특징
    - 거의 비영속 상태에 가깝다. 1차 캐시, 쓰기 지연 등 모든 기능이 작동하지 않음
    - 식별자 값을 가지고 있다.
    - 지연 로딩을 할 수 없다. 지연 로딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방식이다.
    - 준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 `merge(T entity)` (병합) 하면 된다.

- **삭제 (removed)** : 삭제된 상태

#### 비영속 상태와 준영속 상태의 차이점

비영속 상태는 영속성 컨텍스트가 한번도 관리를 한적이 없는 상태이므로 식별자를 가지고 있지 않다. 하지만 준영속 상태는 영속성 컨텍스트가 관리를 하다가 더이상 관리를 하지 않는 상태가 된것이므로 식별자 값이 존재한다.

### 엔티티 조회

영속성 컨텍스트 내부에는 캐시가 있다. 이 캐시는 Map으로 이루어져 있기 때문에 엔티티는 고유의 id가 반드시 필요하다. 즉, 1차 캐시의 키는 식별자 값이다. `EntityManager.find()` 메서드를 실행하면 데이터베이스 찾는게 아니라 우선 메모리에 있는 1차 캐시에서 조회 후 없으면 데이터베이스에서 조회한다. 따라서 찾는 값이 1차 캐시에 없다면 데이터베이스에서 찾은 후 1차 캐시에 저장하여 엔티티를 영속 상태로 만들고 엔티티를 반환한다.

### flush

jpa에서 제공하는 `flush()` 메서드는 영속성 컨텍스트의 변경 내용을 실제 데이터베이스에 반영하는 기능을 제공한다. 다음과 같은 작업을 수행한다.

- 변경 감지 작업 수행
- 쓰기 지연 SQL 저장소의 SQL을 실제 데이터베이스에 전송 (CREATE, UPDATE, DELETE)

영속성 컨텍스트에 flush하는 방법은 3가지가 있다.

- `flush()` 메서드 직접 호출
- 트랜잭션 커밋 시 자동 호출
- JPQL 쿼리 실행시 자동 호출









## OneToMany 문제점

one to many를 통해서 many를 리스트로 가져온다면 one.getList의 형태로 데이터를 가져와야한다. 하지만 one이 존재하지 않는다면 에러가 발생할 것이다. many에서 가져온다면 없을 경우 empty list가 반환되므로 에러가 발생하지 않는다. 따라서 에러를 내보내는 것보다는 리스트의 사이즈로 판별하는 방향이 더 나아보인다.

## Fetch Join

```java
@Query("select m from Member m left outer join fetch Team t")
```

OneToMany는 기본적으로 관계 테이블을 생성시킴 그러므로 관계테이블을 생성시키지 않으려면 관계를 맺어줘야함 -> mappedby, JoinColumn 등

mappedby는 관계의 주인

book - bookStore 가 있다면



book이 관계의 주인이 됨 <- bookStore의 id를 fk로 참조한다는 의미

따라서 OneToMany 관계에서 단순히 리스트에 더해줌으로 저장을 한다면 mappedby 로 엮인 쪽은 실제로 알수 없음 그러므로 fk값을 같이 넣어줘야함

https://www.youtube.com/watch?v=hsSc5epPXDs



### **mappedBy**

mappedBy는 양방향 관계에서 연관관계의 주인을 정의하는 데 사용된다. 연관관계의 주인은 외래 키를 관리하는 쪽. mappedBy를 사용하면 연관관계의 주인이 아닌 쪽에서 사용된다.

- 양방향 관계에서 사용
- 외래 키 관리의 비소유자: `mappedBy` 를 사용하는 엔티티는 외래 키를 직접 관리하지 않으며, 외래 키는 반대쪽 엔티티에 의해 관리된다.
- 속성 이름을 지정: `mappedBy` 는 연관된 엔티티 클래스에서 해당 관계를 나타내는 속성 이름을 지정한다. (데이터베이스 컬럼명X)

**예제**<br/>

Student와 Department 사이의 일대다 관계를 나타낸다. Department가 주인이고, Student가 종속 관계이다.

```java
@Entity
public class Department {
    @Id
    private Long id;

    @OneToMany(mappedBy = "department")
    private List<Student> students;
}

@Entity
public class Student {
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")
    private Department department;
}
```

여기서 Department 클래스는 mappedBy = "department"를 사용하여 Student 클래스에서 이 관계의 주인임을 나타낸다. 반대로, Student 클래스는 @JoinColumn을 사용하여 실제로 외래 키 department_id를 관리한다.

### **@JoinColumn**

@JoinColumn은 외래 키 컬럼을 지정하는 데 사용된다.

- 단방향 또는 양방향 관계에서 사용: @JoinColumn은 양방향 관계에서 주인 엔티티에서 사용되거나 단방향 관계에서도 사용될 수 있다.
- 외래 키 컬럼 명시: 외래 키 컬럼의 이름을 지정할 수 있으며, 이 컬럼을 통해 두 테이블이 연결된다.
- 만약 @JoinColumn을 명시적으로 지정하지 않으면 JPA가 기본 이름을 사용하여 외래 키를 생성한다. 예를 들어, department_id처럼 기본적으로 필드명 + _id 형식으로 생성된다.



### mappedby와 @JoinColumn 차이점

mappedBy는 연관관계의 주인을 지정하여 외래 키를 직접 관리하지 않는 쪽에서 사용되고, @JoinColumn은 외래 키 컬럼을 명시하는 데 사용된다.

mappedBy는 양방향 관계에서 주로 사용되며, 관계를 정의하는 쪽이 아닌 반대쪽에서 사용된다. 반면에 @JoinColumn은 외래 키를 실제로 관리하는 쪽에서 사용.



### Cascade

cascade 옵션은 부모 엔티티에서 자식 엔티티로의 상태 변화를 자동으로 전파하는 기능을 제공한다. 이 옵션을 적절하게 사용하면 엔티티의 생명 주기를 쉽게 관리할 수 있다.

- **CascadeType.PERSIST**: 부모 엔티티의 저장 시 자식 엔티티도 저장.
- **CascadeType.MERGE**: 부모 엔티티의 병합 시 자식 엔티티도 병합.
- **CascadeType.REMOVE**: 부모 엔티티의 삭제 시 자식 엔티티도 삭제.
- **CascadeType.REFRESH**: 부모 엔티티의 갱신 시 자식 엔티티도 갱신.

- **CascadeType.DETACH**: 부모 엔티티가 detach 상태로 전환될 때, 자식 엔티티도 함께 detach 상태로 전환. 이는 엔티티를 영속성 컨텍스트에서 제거하는 것.

- **CascadeType.ALL**: 모든 cascade 타입 적용. 부모 엔티티의 모든 상태 변화를 자식 엔티티에 전파하고 싶을 때 사용





```java
E Hibernate.unproxy(E e)
void Hibernate.initialize(E e)
```



###### 참고

- [JPA ORM 표준 프로그래밍](https://www.yes24.com/product/goods/19040233)
- [더티 체킹](https://jojoldu.tistory.com/415)
